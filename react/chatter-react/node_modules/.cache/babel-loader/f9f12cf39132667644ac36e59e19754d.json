{"ast":null,"code":"/**\n *\n * client\n *\n */\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, parseMessage, stringifyMessage } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\n\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\n\nexport function createClient(options) {\n  const {\n    url,\n    connectionParams,\n    lazy = true,\n    onNonLazyError = console.error,\n    lazyCloseTimeout: lazyCloseTimeoutMs = 0,\n    keepAlive = 0,\n    disablePong,\n    connectionAckWaitTimeout = 0,\n    retryAttempts = 5,\n    retryWait = async function randomisedExponentialBackoff(retries) {\n      let retryDelay = 1000; // start with 1s delay\n\n      for (let i = 0; i < retries; i++) {\n        retryDelay *= 2;\n      }\n\n      await new Promise(resolve => setTimeout(resolve, retryDelay + // add random timeout from 300ms to 3s\n      Math.floor(Math.random() * (3000 - 300) + 300)));\n    },\n    shouldRetry = isLikeCloseEvent,\n    isFatalConnectionProblem,\n    on,\n    webSocketImpl,\n\n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = Math.random() * 16 | 0,\n              v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    },\n    jsonMessageReplacer: replacer,\n    jsonMessageReviver: reviver\n  } = options;\n  let ws;\n\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error('Invalid WebSocket implementation provided');\n    }\n\n    ws = webSocketImpl;\n  } else if (typeof WebSocket !== 'undefined') {\n    ws = WebSocket;\n  } else if (typeof global !== 'undefined') {\n    ws = global.WebSocket || // @ts-expect-error: Support more browsers\n    global.MozWebSocket;\n  } else if (typeof window !== 'undefined') {\n    ws = window.WebSocket || // @ts-expect-error: Support more browsers\n    window.MozWebSocket;\n  }\n\n  if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n  const WebSocketImpl = ws; // websocket status emitter, subscriptions are handled differently\n\n  const emitter = (() => {\n    const message = (() => {\n      const listeners = {};\n      return {\n        on(id, listener) {\n          listeners[id] = listener;\n          return () => {\n            delete listeners[id];\n          };\n        },\n\n        emit(message) {\n          var _a;\n\n          if ('id' in message) (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n        }\n\n      };\n    })();\n\n    const listeners = {\n      connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n      opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n      connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n      ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n      pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n      message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n      closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n      error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n\n      on(event, listener) {\n        const l = listeners[event];\n        l.push(listener);\n        return () => {\n          l.splice(l.indexOf(listener), 1);\n        };\n      },\n\n      emit(event) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n        for (const listener of [...listeners[event]]) {\n          // @ts-expect-error: The args should fit\n          listener(...args);\n        }\n      }\n\n    };\n  })(); // invokes the callback either when an error or closed event is emitted,\n  // first one that gets called prevails, other emissions are ignored\n\n\n  function errorOrClosed(cb) {\n    const listening = [// errors are fatal and more critical than close events, throw them first\n    emitter.on('error', err => {\n      listening.forEach(unlisten => unlisten());\n      cb(err);\n    }), // closes can be graceful and not fatal, throw them second (if error didnt throw)\n    emitter.on('closed', event => {\n      listening.forEach(unlisten => unlisten());\n      cb(event);\n    })];\n  }\n\n  let connecting,\n      locks = 0,\n      lazyCloseTimeout,\n      retrying = false,\n      retries = 0,\n      disposed = false;\n\n  async function connect() {\n    // clear the lazy close timeout immediatelly so that close gets debounced\n    // see: https://github.com/enisdenjo/graphql-ws/issues/388\n    clearTimeout(lazyCloseTimeout);\n    const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied) => (async () => {\n      if (retrying) {\n        await retryWait(retries); // subscriptions might complete while waiting for retry\n\n        if (!locks) {\n          connecting = undefined;\n          return denied({\n            code: 1000,\n            reason: 'All Subscriptions Gone'\n          });\n        }\n\n        retries++;\n      }\n\n      emitter.emit('connecting');\n      const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n      let connectionAckTimeout, queuedPing;\n\n      function enqueuePing() {\n        if (isFinite(keepAlive) && keepAlive > 0) {\n          clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n\n          queuedPing = setTimeout(() => {\n            if (socket.readyState === WebSocketImpl.OPEN) {\n              socket.send(stringifyMessage({\n                type: MessageType.Ping\n              }));\n              emitter.emit('ping', false, undefined);\n            }\n          }, keepAlive);\n        }\n      }\n\n      errorOrClosed(errOrEvent => {\n        connecting = undefined;\n        clearTimeout(connectionAckTimeout);\n        clearTimeout(queuedPing);\n        denied(errOrEvent);\n\n        if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n          socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n\n          socket.onerror = null;\n          socket.onclose = null;\n        }\n      });\n\n      socket.onerror = err => emitter.emit('error', err);\n\n      socket.onclose = event => emitter.emit('closed', event);\n\n      socket.onopen = async () => {\n        try {\n          emitter.emit('opened', socket);\n          const payload = typeof connectionParams === 'function' ? await connectionParams() : connectionParams; // connectionParams might take too long causing the server to kick off the client\n          // the necessary error/close event is already reported - simply stop execution\n\n          if (socket.readyState !== WebSocketImpl.OPEN) return;\n          socket.send(stringifyMessage(payload ? {\n            type: MessageType.ConnectionInit,\n            payload\n          } : {\n            type: MessageType.ConnectionInit // payload is completely absent if not provided\n\n          }, replacer));\n\n          if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n            connectionAckTimeout = setTimeout(() => {\n              socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n            }, connectionAckWaitTimeout);\n          }\n\n          enqueuePing(); // enqueue ping (noop if disabled)\n        } catch (err) {\n          emitter.emit('error', err);\n          socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n        }\n      };\n\n      let acknowledged = false;\n\n      socket.onmessage = _ref => {\n        let {\n          data\n        } = _ref;\n\n        try {\n          const message = parseMessage(data, reviver);\n          emitter.emit('message', message);\n\n          if (message.type === 'ping' || message.type === 'pong') {\n            emitter.emit(message.type, true, message.payload); // received\n\n            if (message.type === 'pong') {\n              enqueuePing(); // enqueue next ping (noop if disabled)\n            } else if (!disablePong) {\n              // respond with pong on ping\n              socket.send(stringifyMessage(message.payload ? {\n                type: MessageType.Pong,\n                payload: message.payload\n              } : {\n                type: MessageType.Pong // payload is completely absent if not provided\n\n              }));\n              emitter.emit('pong', false, message.payload);\n            }\n\n            return; // ping and pongs can be received whenever\n          }\n\n          if (acknowledged) return; // already connected and acknowledged\n\n          if (message.type !== MessageType.ConnectionAck) throw new Error(`First message cannot be of type ${message.type}`);\n          clearTimeout(connectionAckTimeout);\n          acknowledged = true;\n          emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n\n          retrying = false; // future lazy connects are not retries\n\n          retries = 0; // reset the retries on connect\n\n          connected([socket, new Promise((_, reject) => errorOrClosed(reject))]);\n        } catch (err) {\n          socket.onmessage = null; // stop reading messages as soon as reading breaks once\n\n          emitter.emit('error', err);\n          socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n        }\n      };\n    })())); // if the provided socket is in a closing state, wait for the throw on close\n\n    if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n\n    let release = () => {// releases this connection\n    };\n\n    const released = new Promise(resolve => release = resolve);\n    return [socket, release, Promise.race([// wait for\n    released.then(() => {\n      if (!locks) {\n        // and if no more locks are present, complete the connection\n        const complete = () => socket.close(1000, 'Normal Closure');\n\n        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n          // if the keepalive is set, allow for the specified calmdown time and\n          // then complete if the socket is still open.\n          lazyCloseTimeout = setTimeout(() => {\n            if (socket.readyState === WebSocketImpl.OPEN) complete();\n          }, lazyCloseTimeoutMs);\n        } else {\n          // otherwise complete immediately\n          complete();\n        }\n      }\n    }), // or\n    throwOnClose])];\n  }\n  /**\n   * Checks the `connect` problem and evaluates if the client should retry.\n   */\n\n\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    // some close codes are worth reporting immediately\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [CloseCode.InternalServerError, CloseCode.InternalClientError, CloseCode.BadRequest, CloseCode.BadResponse, CloseCode.Unauthorized, // CloseCode.Forbidden, might grant access out after retry\n    CloseCode.SubprotocolNotAcceptable, // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n    CloseCode.SubscriberAlreadyExists, CloseCode.TooManyInitialisationRequests // 4499, // Terminated, probably because the socket froze, we want to retry\n    ].includes(errOrCloseEvent.code))) throw errOrCloseEvent; // client was disposed, no retries should proceed regardless\n\n    if (disposed) return false; // normal closure (possibly all subscriptions have completed)\n    // if no locks were acquired in the meantime, shouldnt try again\n\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000) return locks > 0; // retries are not allowed or we tried to many times, report error\n\n    if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent; // throw non-retryable connection problems\n\n    if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent; // @deprecated throw fatal connection problems immediately\n\n    if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent)) throw errOrCloseEvent; // looks good, start retrying\n\n    return retrying = true;\n  } // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n\n\n  if (!lazy) {\n    (async () => {\n      locks++;\n\n      for (;;) {\n        try {\n          const [,, throwOnClose] = await connect();\n          await throwOnClose; // will always throw because releaser is not used\n        } catch (errOrCloseEvent) {\n          try {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          } catch (errOrCloseEvent) {\n            // report thrown error, no further retries\n            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n          }\n        }\n      }\n    })();\n  }\n\n  return {\n    on: emitter.on,\n\n    subscribe(payload, sink) {\n      const id = generateID(payload);\n\n      let done = false,\n          errored = false,\n          releaser = () => {\n        // for handling completions before connect\n        locks--;\n        done = true;\n      };\n\n      (async () => {\n        locks++;\n\n        for (;;) {\n          try {\n            const [socket, release, waitForReleaseOrThrowOnClose] = await connect(); // if done while waiting for connect, release the connection lock right away\n\n            if (done) return release();\n            const unlisten = emitter.onMessage(id, message => {\n              switch (message.type) {\n                case MessageType.Next:\n                  {\n                    sink.next(message.payload);\n                    return;\n                  }\n\n                case MessageType.Error:\n                  {\n                    errored = true, done = true;\n                    sink.error(message.payload);\n                    releaser();\n                    return;\n                  }\n\n                case MessageType.Complete:\n                  {\n                    done = true;\n                    releaser(); // release completes the sink\n\n                    return;\n                  }\n              }\n            });\n            socket.send(stringifyMessage({\n              id,\n              type: MessageType.Subscribe,\n              payload\n            }, replacer));\n\n            releaser = () => {\n              if (!done && socket.readyState === WebSocketImpl.OPEN) // if not completed already and socket is open, send complete message to server on release\n                socket.send(stringifyMessage({\n                  id,\n                  type: MessageType.Complete\n                }, replacer));\n              locks--;\n              done = true;\n              release();\n            }; // either the releaser will be called, connection completed and\n            // the promise resolved or the socket closed and the promise rejected.\n            // whatever happens though, we want to stop listening for messages\n\n\n            await waitForReleaseOrThrowOnClose.finally(unlisten);\n            return; // completed, shouldnt try again\n          } catch (errOrCloseEvent) {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          }\n        }\n      })().then(() => {\n        // delivering either an error or a complete terminates the sequence\n        if (!errored) sink.complete();\n      }) // resolves on release or normal closure\n      .catch(err => {\n        sink.error(err);\n      }); // rejects on close events and errors\n\n      return () => {\n        // dispose only of active subscriptions\n        if (!done) releaser();\n      };\n    },\n\n    async dispose() {\n      disposed = true;\n\n      if (connecting) {\n        // if there is a connection, close it\n        const [socket] = await connecting;\n        socket.close(1000, 'Normal Closure');\n      }\n    },\n\n    terminate() {\n      if (connecting) {\n        // only if there is a connection\n        emitter.emit('closed', {\n          code: 4499,\n          reason: 'Terminated',\n          wasClean: false\n        });\n      }\n    }\n\n  };\n}\n\nfunction isLikeCloseEvent(val) {\n  return isObject(val) && 'code' in val && 'reason' in val;\n}\n\nfunction isFatalInternalCloseCode(code) {\n  if ([1000, 1001, 1006, 1005, 1012, 1013, 1013 // Bad Gateway\n  ].includes(code)) return false; // all other internal errors are fatal\n\n  return code >= 1000 && code <= 1999;\n}\n\nfunction isWebSocket(val) {\n  return typeof val === 'function' && 'constructor' in val && 'CLOSED' in val && 'CLOSING' in val && 'CONNECTING' in val && 'OPEN' in val;\n}","map":{"version":3,"names":["GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","parseMessage","stringifyMessage","isObject","limitCloseReason","createClient","options","url","connectionParams","lazy","onNonLazyError","console","error","lazyCloseTimeout","lazyCloseTimeoutMs","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","randomisedExponentialBackoff","retries","retryDelay","i","Promise","resolve","setTimeout","Math","floor","random","shouldRetry","isLikeCloseEvent","isFatalConnectionProblem","on","webSocketImpl","generateID","generateUUID","replace","c","r","v","toString","jsonMessageReplacer","replacer","jsonMessageReviver","reviver","ws","isWebSocket","Error","WebSocket","global","MozWebSocket","window","WebSocketImpl","emitter","message","listeners","id","listener","emit","_a","call","connecting","opened","connected","ping","pong","closed","onMessage","event","l","push","splice","indexOf","args","errorOrClosed","cb","listening","err","forEach","unlisten","locks","retrying","disposed","connect","clearTimeout","socket","throwOnClose","denied","undefined","code","reason","connectionAckTimeout","queuedPing","enqueuePing","isFinite","readyState","OPEN","send","type","Ping","errOrEvent","close","onerror","onclose","onopen","payload","ConnectionInit","ConnectionAcknowledgementTimeout","InternalClientError","acknowledged","onmessage","data","Pong","ConnectionAck","_","reject","BadResponse","CLOSING","release","released","race","then","complete","shouldRetryConnectOrThrow","errOrCloseEvent","isFatalInternalCloseCode","InternalServerError","BadRequest","Unauthorized","SubprotocolNotAcceptable","SubscriberAlreadyExists","TooManyInitialisationRequests","includes","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","Next","next","Complete","Subscribe","finally","catch","dispose","terminate","wasClean","val"],"sources":["/home/xeg/dev/chatter-web/frontend/react/chatter-react/node_modules/graphql-ws/lib/client.mjs"],"sourcesContent":["/**\n *\n * client\n *\n */\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, parseMessage, stringifyMessage, } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nexport function createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting');\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send(stringifyMessage({ type: MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (isLikeCloseEvent(errOrEvent) && errOrEvent.code === 4499) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send(stringifyMessage(payload\n                        ? {\n                            type: MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = parseMessage(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send(stringifyMessage(message.payload\n                                ? {\n                                    type: MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    CloseCode.InternalServerError,\n                    CloseCode.InternalClientError,\n                    CloseCode.BadRequest,\n                    CloseCode.BadResponse,\n                    CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    CloseCode.SubscriberAlreadyExists,\n                    CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    return {\n        on: emitter.on,\n        subscribe(payload, sink) {\n            const id = generateID(payload);\n            let done = false, errored = false, releaser = () => {\n                // for handling completions before connect\n                locks--;\n                done = true;\n            };\n            (async () => {\n                locks++;\n                for (;;) {\n                    try {\n                        const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                        // if done while waiting for connect, release the connection lock right away\n                        if (done)\n                            return release();\n                        const unlisten = emitter.onMessage(id, (message) => {\n                            switch (message.type) {\n                                case MessageType.Next: {\n                                    sink.next(message.payload);\n                                    return;\n                                }\n                                case MessageType.Error: {\n                                    (errored = true), (done = true);\n                                    sink.error(message.payload);\n                                    releaser();\n                                    return;\n                                }\n                                case MessageType.Complete: {\n                                    done = true;\n                                    releaser(); // release completes the sink\n                                    return;\n                                }\n                            }\n                        });\n                        socket.send(stringifyMessage({\n                            id,\n                            type: MessageType.Subscribe,\n                            payload,\n                        }, replacer));\n                        releaser = () => {\n                            if (!done && socket.readyState === WebSocketImpl.OPEN)\n                                // if not completed already and socket is open, send complete message to server on release\n                                socket.send(stringifyMessage({\n                                    id,\n                                    type: MessageType.Complete,\n                                }, replacer));\n                            locks--;\n                            done = true;\n                            release();\n                        };\n                        // either the releaser will be called, connection completed and\n                        // the promise resolved or the socket closed and the promise rejected.\n                        // whatever happens though, we want to stop listening for messages\n                        await waitForReleaseOrThrowOnClose.finally(unlisten);\n                        return; // completed, shouldnt try again\n                    }\n                    catch (errOrCloseEvent) {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                }\n            })()\n                .then(() => {\n                // delivering either an error or a complete terminates the sequence\n                if (!errored)\n                    sink.complete();\n            }) // resolves on release or normal closure\n                .catch((err) => {\n                sink.error(err);\n            }); // rejects on close events and errors\n            return () => {\n                // dispose only of active subscriptions\n                if (!done)\n                    releaser();\n            };\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', {\n                    code: 4499,\n                    reason: 'Terminated',\n                    wasClean: false,\n                });\n            }\n        },\n    };\n}\nfunction isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1013, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}