{"ast":null,"code":"/**\n *\n * server\n *\n */\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError } from 'graphql';\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage } from './common.mjs';\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors } from './utils.mjs';\n/**\n * Makes a Protocol complient WebSocket GraphQL server. The server\n * is actually an API which is to be used with your favourite WebSocket\n * server library!\n *\n * Read more about the Protocol in the PROTOCOL.md documentation file.\n *\n * @category Server\n */\n\nexport function makeServer(options) {\n  const {\n    schema,\n    context,\n    roots,\n    validate,\n    execute,\n    subscribe,\n    connectionInitWaitTimeout = 3000,\n    // 3 seconds\n    onConnect,\n    onDisconnect,\n    onClose,\n    onSubscribe,\n    onOperation,\n    onNext,\n    onError,\n    onComplete,\n    jsonMessageReviver: reviver,\n    jsonMessageReplacer: replacer\n  } = options;\n  return {\n    opened(socket, extra) {\n      const ctx = {\n        connectionInitReceived: false,\n        acknowledged: false,\n        subscriptions: {},\n        extra\n      };\n\n      if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n        socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n        return async (code, reason) => {\n          /* nothing was set up, just notify the closure */\n          await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n        };\n      } // kick the client off (close socket) if the connection has\n      // not been initialised after the specified wait timeout\n\n\n      const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout) ? setTimeout(() => {\n        if (!ctx.connectionInitReceived) socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n      }, connectionInitWaitTimeout) : null;\n      socket.onMessage(async function onMessage(data) {\n        var e_1, _a;\n\n        var _b;\n\n        let message;\n\n        try {\n          message = parseMessage(data, reviver);\n        } catch (err) {\n          return socket.close(CloseCode.BadRequest, 'Invalid message received');\n        }\n\n        switch (message.type) {\n          case MessageType.ConnectionInit:\n            {\n              if (ctx.connectionInitReceived) return socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests'); // @ts-expect-error: I can write\n\n              ctx.connectionInitReceived = true;\n              if (isObject(message.payload)) // @ts-expect-error: I can write\n                ctx.connectionParams = message.payload;\n              const permittedOrPayload = await (onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx));\n              if (permittedOrPayload === false) return socket.close(CloseCode.Forbidden, 'Forbidden');\n              await socket.send(stringifyMessage(isObject(permittedOrPayload) ? {\n                type: MessageType.ConnectionAck,\n                payload: permittedOrPayload\n              } : {\n                type: MessageType.ConnectionAck // payload is completely absent if not provided\n\n              }, replacer)); // @ts-expect-error: I can write\n\n              ctx.acknowledged = true;\n              return;\n            }\n\n          case MessageType.Ping:\n            {\n              if (socket.onPing) // if the onPing listener is registered, automatic pong is disabled\n                return await socket.onPing(message.payload);\n              await socket.send(stringifyMessage(message.payload ? {\n                type: MessageType.Pong,\n                payload: message.payload\n              } : {\n                type: MessageType.Pong // payload is completely absent if not provided\n\n              }));\n              return;\n            }\n\n          case MessageType.Pong:\n            return await ((_b = socket.onPong) === null || _b === void 0 ? void 0 : _b.call(socket, message.payload));\n\n          case MessageType.Subscribe:\n            {\n              if (!ctx.acknowledged) return socket.close(CloseCode.Unauthorized, 'Unauthorized');\n              const {\n                id,\n                payload\n              } = message;\n              if (id in ctx.subscriptions) return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`); // if this turns out to be a streaming operation, the subscription value\n              // will change to an `AsyncIterable`, otherwise it will stay as is\n\n              ctx.subscriptions[id] = null;\n              const emit = {\n                next: async (result, args) => {\n                  let nextMessage = {\n                    id,\n                    type: MessageType.Next,\n                    payload: result\n                  };\n                  const maybeResult = await (onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result));\n                  if (maybeResult) nextMessage = Object.assign(Object.assign({}, nextMessage), {\n                    payload: maybeResult\n                  });\n                  await socket.send(stringifyMessage(nextMessage, replacer));\n                },\n                error: async errors => {\n                  let errorMessage = {\n                    id,\n                    type: MessageType.Error,\n                    payload: errors\n                  };\n                  const maybeErrors = await (onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors));\n                  if (maybeErrors) errorMessage = Object.assign(Object.assign({}, errorMessage), {\n                    payload: maybeErrors\n                  });\n                  await socket.send(stringifyMessage(errorMessage, replacer));\n                },\n                complete: async notifyClient => {\n                  const completeMessage = {\n                    id,\n                    type: MessageType.Complete\n                  };\n                  await (onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage));\n                  if (notifyClient) await socket.send(stringifyMessage(completeMessage, replacer));\n                }\n              };\n\n              try {\n                let execArgs;\n                const maybeExecArgsOrErrors = await (onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message));\n\n                if (maybeExecArgsOrErrors) {\n                  if (areGraphQLErrors(maybeExecArgsOrErrors)) return await emit.error(maybeExecArgsOrErrors);else if (Array.isArray(maybeExecArgsOrErrors)) throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects'); // not errors, is exec args\n\n                  execArgs = maybeExecArgsOrErrors;\n                } else {\n                  // you either provide a schema dynamically through\n                  // `onSubscribe` or you set one up during the server setup\n                  if (!schema) throw new Error('The GraphQL schema is not provided');\n                  const args = {\n                    operationName: payload.operationName,\n                    document: parse(payload.query),\n                    variableValues: payload.variables\n                  };\n                  execArgs = Object.assign(Object.assign({}, args), {\n                    schema: typeof schema === 'function' ? await schema(ctx, message, args) : schema\n                  });\n                  const validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\n                  if (validationErrors.length > 0) return await emit.error(validationErrors);\n                }\n\n                const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                if (!operationAST) return await emit.error([new GraphQLError('Unable to identify operation')]); // if `onSubscribe` didnt specify a rootValue, inject one\n\n                if (!('rootValue' in execArgs)) execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation]; // if `onSubscribe` didn't specify a context, inject one\n\n                if (!('contextValue' in execArgs)) execArgs.contextValue = typeof context === 'function' ? await context(ctx, message, execArgs) : context; // the execution arguments have been prepared\n                // perform the operation and act accordingly\n\n                let operationResult;\n                if (operationAST.operation === 'subscription') operationResult = await (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs); // operation === 'query' || 'mutation'\n                else operationResult = await (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\n                const maybeResult = await (onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult));\n                if (maybeResult) operationResult = maybeResult;\n\n                if (isAsyncIterable(operationResult)) {\n                  /** multiple emitted results */\n                  if (!(id in ctx.subscriptions)) {\n                    // subscription was completed/canceled before the operation settled\n                    if (isAsyncGenerator(operationResult)) operationResult.return(undefined);\n                  } else {\n                    ctx.subscriptions[id] = operationResult;\n\n                    try {\n                      for (var operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = await operationResult_1.next(), !operationResult_1_1.done;) {\n                        const result = operationResult_1_1.value;\n                        await emit.next(result, execArgs);\n                      }\n                    } catch (e_1_1) {\n                      e_1 = {\n                        error: e_1_1\n                      };\n                    } finally {\n                      try {\n                        if (operationResult_1_1 && !operationResult_1_1.done && (_a = operationResult_1.return)) await _a.call(operationResult_1);\n                      } finally {\n                        if (e_1) throw e_1.error;\n                      }\n                    }\n                  }\n                } else {\n                  /** single emitted result */\n                  // if the client completed the subscription before the single result\n                  // became available, he effectively canceled it and no data should be sent\n                  if (id in ctx.subscriptions) await emit.next(operationResult, execArgs);\n                } // lack of subscription at this point indicates that the client\n                // completed the subscription, he doesnt need to be reminded\n\n\n                await emit.complete(id in ctx.subscriptions);\n              } finally {\n                // whatever happens to the subscription, we finally want to get rid of the reservation\n                delete ctx.subscriptions[id];\n              }\n\n              return;\n            }\n\n          case MessageType.Complete:\n            {\n              const subscription = ctx.subscriptions[message.id];\n              delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n\n              if (isAsyncGenerator(subscription)) await subscription.return(undefined);\n              return;\n            }\n\n          default:\n            throw new Error(`Unexpected message of type ${message.type} received`);\n        }\n      }); // wait for close, cleanup and the disconnect callback\n\n      return async (code, reason) => {\n        if (connectionInitWait) clearTimeout(connectionInitWait);\n\n        for (const sub of Object.values(ctx.subscriptions)) {\n          if (isAsyncGenerator(sub)) await sub.return(undefined);\n        }\n\n        if (ctx.acknowledged) await (onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason));\n        await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n      };\n    }\n\n  };\n}\n/**\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\n * a set of WebSocket subprotocols.\n *\n * Accepts a set of already extracted WebSocket subprotocols or the raw\n * Sec-WebSocket-Protocol header value. In either case, if the right\n * protocol appears, it will be returned.\n *\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\n * if it does not agree with client's subprotocols. The client has a responsibility\n * to handle the connection afterwards.\n *\n * @category Server\n */\n\nexport function handleProtocols(protocols) {\n  switch (true) {\n    case protocols instanceof Set && protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case Array.isArray(protocols) && protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case typeof protocols === 'string' && protocols.split(',').map(p => p.trim()).includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n      return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","Promise","resolve","reject","settle","done","value","d","then","parse","validate","graphqlValidate","execute","graphqlExecute","subscribe","graphqlSubscribe","getOperationAST","GraphQLError","GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","stringifyMessage","parseMessage","isObject","isAsyncGenerator","isAsyncIterable","areGraphQLErrors","makeServer","options","schema","context","roots","connectionInitWaitTimeout","onConnect","onDisconnect","onClose","onSubscribe","onOperation","onNext","onError","onComplete","jsonMessageReviver","reviver","jsonMessageReplacer","replacer","opened","socket","extra","ctx","connectionInitReceived","acknowledged","subscriptions","protocol","close","SubprotocolNotAcceptable","code","reason","connectionInitWait","isFinite","setTimeout","ConnectionInitialisationTimeout","onMessage","data","e_1","_a","_b","message","err","BadRequest","type","ConnectionInit","TooManyInitialisationRequests","payload","connectionParams","permittedOrPayload","Forbidden","send","ConnectionAck","Ping","onPing","Pong","onPong","Subscribe","Unauthorized","id","SubscriberAlreadyExists","emit","next","result","args","nextMessage","Next","maybeResult","Object","assign","error","errors","errorMessage","Error","maybeErrors","complete","notifyClient","completeMessage","Complete","execArgs","maybeExecArgsOrErrors","Array","isArray","operationName","document","query","variableValues","variables","validationErrors","length","operationAST","rootValue","operation","contextValue","operationResult","return","undefined","operationResult_1","operationResult_1_1","e_1_1","subscription","clearTimeout","sub","values","handleProtocols","protocols","Set","has","includes","split","map","p","trim"],"sources":["/home/xeg/dev/chatter-web/frontend/react/chatter-react/node_modules/graphql-ws/lib/server.mjs"],"sourcesContent":["/**\n *\n * server\n *\n */\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError, } from 'graphql';\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage, } from './common.mjs';\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors, } from './utils.mjs';\n/**\n * Makes a Protocol complient WebSocket GraphQL server. The server\n * is actually an API which is to be used with your favourite WebSocket\n * server library!\n *\n * Read more about the Protocol in the PROTOCOL.md documentation file.\n *\n * @category Server\n */\nexport function makeServer(options) {\n    const { schema, context, roots, validate, execute, subscribe, connectionInitWaitTimeout = 3000, // 3 seconds\n    onConnect, onDisconnect, onClose, onSubscribe, onOperation, onNext, onError, onComplete, jsonMessageReviver: reviver, jsonMessageReplacer: replacer, } = options;\n    return {\n        opened(socket, extra) {\n            const ctx = {\n                connectionInitReceived: false,\n                acknowledged: false,\n                subscriptions: {},\n                extra,\n            };\n            if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n                socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n                return async (code, reason) => {\n                    /* nothing was set up, just notify the closure */\n                    await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n                };\n            }\n            // kick the client off (close socket) if the connection has\n            // not been initialised after the specified wait timeout\n            const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout)\n                ? setTimeout(() => {\n                    if (!ctx.connectionInitReceived)\n                        socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n                }, connectionInitWaitTimeout)\n                : null;\n            socket.onMessage(async function onMessage(data) {\n                var e_1, _a;\n                var _b;\n                let message;\n                try {\n                    message = parseMessage(data, reviver);\n                }\n                catch (err) {\n                    return socket.close(CloseCode.BadRequest, 'Invalid message received');\n                }\n                switch (message.type) {\n                    case MessageType.ConnectionInit: {\n                        if (ctx.connectionInitReceived)\n                            return socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests');\n                        // @ts-expect-error: I can write\n                        ctx.connectionInitReceived = true;\n                        if (isObject(message.payload))\n                            // @ts-expect-error: I can write\n                            ctx.connectionParams = message.payload;\n                        const permittedOrPayload = await (onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx));\n                        if (permittedOrPayload === false)\n                            return socket.close(CloseCode.Forbidden, 'Forbidden');\n                        await socket.send(stringifyMessage(isObject(permittedOrPayload)\n                            ? {\n                                type: MessageType.ConnectionAck,\n                                payload: permittedOrPayload,\n                            }\n                            : {\n                                type: MessageType.ConnectionAck,\n                                // payload is completely absent if not provided\n                            }, replacer));\n                        // @ts-expect-error: I can write\n                        ctx.acknowledged = true;\n                        return;\n                    }\n                    case MessageType.Ping: {\n                        if (socket.onPing)\n                            // if the onPing listener is registered, automatic pong is disabled\n                            return await socket.onPing(message.payload);\n                        await socket.send(stringifyMessage(message.payload\n                            ? { type: MessageType.Pong, payload: message.payload }\n                            : {\n                                type: MessageType.Pong,\n                                // payload is completely absent if not provided\n                            }));\n                        return;\n                    }\n                    case MessageType.Pong:\n                        return await ((_b = socket.onPong) === null || _b === void 0 ? void 0 : _b.call(socket, message.payload));\n                    case MessageType.Subscribe: {\n                        if (!ctx.acknowledged)\n                            return socket.close(CloseCode.Unauthorized, 'Unauthorized');\n                        const { id, payload } = message;\n                        if (id in ctx.subscriptions)\n                            return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\n                        // if this turns out to be a streaming operation, the subscription value\n                        // will change to an `AsyncIterable`, otherwise it will stay as is\n                        ctx.subscriptions[id] = null;\n                        const emit = {\n                            next: async (result, args) => {\n                                let nextMessage = {\n                                    id,\n                                    type: MessageType.Next,\n                                    payload: result,\n                                };\n                                const maybeResult = await (onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result));\n                                if (maybeResult)\n                                    nextMessage = Object.assign(Object.assign({}, nextMessage), { payload: maybeResult });\n                                await socket.send(stringifyMessage(nextMessage, replacer));\n                            },\n                            error: async (errors) => {\n                                let errorMessage = {\n                                    id,\n                                    type: MessageType.Error,\n                                    payload: errors,\n                                };\n                                const maybeErrors = await (onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors));\n                                if (maybeErrors)\n                                    errorMessage = Object.assign(Object.assign({}, errorMessage), { payload: maybeErrors });\n                                await socket.send(stringifyMessage(errorMessage, replacer));\n                            },\n                            complete: async (notifyClient) => {\n                                const completeMessage = {\n                                    id,\n                                    type: MessageType.Complete,\n                                };\n                                await (onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage));\n                                if (notifyClient)\n                                    await socket.send(stringifyMessage(completeMessage, replacer));\n                            },\n                        };\n                        try {\n                            let execArgs;\n                            const maybeExecArgsOrErrors = await (onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message));\n                            if (maybeExecArgsOrErrors) {\n                                if (areGraphQLErrors(maybeExecArgsOrErrors))\n                                    return await emit.error(maybeExecArgsOrErrors);\n                                else if (Array.isArray(maybeExecArgsOrErrors))\n                                    throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\n                                // not errors, is exec args\n                                execArgs = maybeExecArgsOrErrors;\n                            }\n                            else {\n                                // you either provide a schema dynamically through\n                                // `onSubscribe` or you set one up during the server setup\n                                if (!schema)\n                                    throw new Error('The GraphQL schema is not provided');\n                                const args = {\n                                    operationName: payload.operationName,\n                                    document: parse(payload.query),\n                                    variableValues: payload.variables,\n                                };\n                                execArgs = Object.assign(Object.assign({}, args), { schema: typeof schema === 'function'\n                                        ? await schema(ctx, message, args)\n                                        : schema });\n                                const validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\n                                if (validationErrors.length > 0)\n                                    return await emit.error(validationErrors);\n                            }\n                            const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                            if (!operationAST)\n                                return await emit.error([\n                                    new GraphQLError('Unable to identify operation'),\n                                ]);\n                            // if `onSubscribe` didnt specify a rootValue, inject one\n                            if (!('rootValue' in execArgs))\n                                execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\n                            // if `onSubscribe` didn't specify a context, inject one\n                            if (!('contextValue' in execArgs))\n                                execArgs.contextValue =\n                                    typeof context === 'function'\n                                        ? await context(ctx, message, execArgs)\n                                        : context;\n                            // the execution arguments have been prepared\n                            // perform the operation and act accordingly\n                            let operationResult;\n                            if (operationAST.operation === 'subscription')\n                                operationResult = await (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs);\n                            // operation === 'query' || 'mutation'\n                            else\n                                operationResult = await (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\n                            const maybeResult = await (onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult));\n                            if (maybeResult)\n                                operationResult = maybeResult;\n                            if (isAsyncIterable(operationResult)) {\n                                /** multiple emitted results */\n                                if (!(id in ctx.subscriptions)) {\n                                    // subscription was completed/canceled before the operation settled\n                                    if (isAsyncGenerator(operationResult))\n                                        operationResult.return(undefined);\n                                }\n                                else {\n                                    ctx.subscriptions[id] = operationResult;\n                                    try {\n                                        for (var operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = await operationResult_1.next(), !operationResult_1_1.done;) {\n                                            const result = operationResult_1_1.value;\n                                            await emit.next(result, execArgs);\n                                        }\n                                    }\n                                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                                    finally {\n                                        try {\n                                            if (operationResult_1_1 && !operationResult_1_1.done && (_a = operationResult_1.return)) await _a.call(operationResult_1);\n                                        }\n                                        finally { if (e_1) throw e_1.error; }\n                                    }\n                                }\n                            }\n                            else {\n                                /** single emitted result */\n                                // if the client completed the subscription before the single result\n                                // became available, he effectively canceled it and no data should be sent\n                                if (id in ctx.subscriptions)\n                                    await emit.next(operationResult, execArgs);\n                            }\n                            // lack of subscription at this point indicates that the client\n                            // completed the subscription, he doesnt need to be reminded\n                            await emit.complete(id in ctx.subscriptions);\n                        }\n                        finally {\n                            // whatever happens to the subscription, we finally want to get rid of the reservation\n                            delete ctx.subscriptions[id];\n                        }\n                        return;\n                    }\n                    case MessageType.Complete: {\n                        const subscription = ctx.subscriptions[message.id];\n                        delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n                        if (isAsyncGenerator(subscription))\n                            await subscription.return(undefined);\n                        return;\n                    }\n                    default:\n                        throw new Error(`Unexpected message of type ${message.type} received`);\n                }\n            });\n            // wait for close, cleanup and the disconnect callback\n            return async (code, reason) => {\n                if (connectionInitWait)\n                    clearTimeout(connectionInitWait);\n                for (const sub of Object.values(ctx.subscriptions)) {\n                    if (isAsyncGenerator(sub))\n                        await sub.return(undefined);\n                }\n                if (ctx.acknowledged)\n                    await (onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason));\n                await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n            };\n        },\n    };\n}\n/**\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\n * a set of WebSocket subprotocols.\n *\n * Accepts a set of already extracted WebSocket subprotocols or the raw\n * Sec-WebSocket-Protocol header value. In either case, if the right\n * protocol appears, it will be returned.\n *\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\n * if it does not agree with client's subprotocols. The client has a responsibility\n * to handle the connection afterwards.\n *\n * @category Server\n */\nexport function handleProtocols(protocols) {\n    switch (true) {\n        case protocols instanceof Set &&\n            protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case Array.isArray(protocols) &&\n            protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case typeof protocols === 'string' &&\n            protocols\n                .split(',')\n                .map((p) => p.trim())\n                .includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n            return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n        default:\n            return false;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,aAAa,GAAI,QAAQ,KAAKA,aAAd,IAAgC,UAAUC,CAAV,EAAa;EAC7D,IAAI,CAACC,MAAM,CAACC,aAAZ,EAA2B,MAAM,IAAIC,SAAJ,CAAc,sCAAd,CAAN;EAC3B,IAAIC,CAAC,GAAGJ,CAAC,CAACC,MAAM,CAACC,aAAR,CAAT;EAAA,IAAiCG,CAAjC;EACA,OAAOD,CAAC,GAAGA,CAAC,CAACE,IAAF,CAAON,CAAP,CAAH,IAAgBA,CAAC,GAAG,OAAOO,QAAP,KAAoB,UAApB,GAAiCA,QAAQ,CAACP,CAAD,CAAzC,GAA+CA,CAAC,CAACC,MAAM,CAACO,QAAR,CAAD,EAAnD,EAAyEH,CAAC,GAAG,EAA7E,EAAiFI,IAAI,CAAC,MAAD,CAArF,EAA+FA,IAAI,CAAC,OAAD,CAAnG,EAA8GA,IAAI,CAAC,QAAD,CAAlH,EAA8HJ,CAAC,CAACJ,MAAM,CAACC,aAAR,CAAD,GAA0B,YAAY;IAAE,OAAO,IAAP;EAAc,CAApL,EAAsLG,CAAtM,CAAR;;EACA,SAASI,IAAT,CAAcC,CAAd,EAAiB;IAAEL,CAAC,CAACK,CAAD,CAAD,GAAOV,CAAC,CAACU,CAAD,CAAD,IAAQ,UAAUC,CAAV,EAAa;MAAE,OAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;QAAEH,CAAC,GAAGX,CAAC,CAACU,CAAD,CAAD,CAAKC,CAAL,CAAJ,EAAaI,MAAM,CAACF,OAAD,EAAUC,MAAV,EAAkBH,CAAC,CAACK,IAApB,EAA0BL,CAAC,CAACM,KAA5B,CAAnB;MAAwD,CAAjG,CAAP;IAA4G,CAA1I;EAA6I;;EAChK,SAASF,MAAT,CAAgBF,OAAhB,EAAyBC,MAAzB,EAAiCI,CAAjC,EAAoCP,CAApC,EAAuC;IAAEC,OAAO,CAACC,OAAR,CAAgBF,CAAhB,EAAmBQ,IAAnB,CAAwB,UAASR,CAAT,EAAY;MAAEE,OAAO,CAAC;QAAEI,KAAK,EAAEN,CAAT;QAAYK,IAAI,EAAEE;MAAlB,CAAD,CAAP;IAAiC,CAAvE,EAAyEJ,MAAzE;EAAmF;AAC/H,CAND;;AAOA,SAASM,KAAT,EAAgBC,QAAQ,IAAIC,eAA5B,EAA6CC,OAAO,IAAIC,cAAxD,EAAwEC,SAAS,IAAIC,gBAArF,EAAuGC,eAAvG,EAAwHC,YAAxH,QAA6I,SAA7I;AACA,SAASC,6BAAT,EAAwCC,SAAxC,EAAmDC,WAAnD,EAAgEC,gBAAhE,EAAkFC,YAAlF,QAAuG,cAAvG;AACA,SAASC,QAAT,EAAmBC,gBAAnB,EAAqCC,eAArC,EAAsDC,gBAAtD,QAA+E,aAA/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBC,OAApB,EAA6B;EAChC,MAAM;IAAEC,MAAF;IAAUC,OAAV;IAAmBC,KAAnB;IAA0BrB,QAA1B;IAAoCE,OAApC;IAA6CE,SAA7C;IAAwDkB,yBAAyB,GAAG,IAApF;IAA0F;IAChGC,SADM;IACKC,YADL;IACmBC,OADnB;IAC4BC,WAD5B;IACyCC,WADzC;IACsDC,MADtD;IAC8DC,OAD9D;IACuEC,UADvE;IACmFC,kBAAkB,EAAEC,OADvG;IACgHC,mBAAmB,EAAEC;EADrI,IACmJhB,OADzJ;EAEA,OAAO;IACHiB,MAAM,CAACC,MAAD,EAASC,KAAT,EAAgB;MAClB,MAAMC,GAAG,GAAG;QACRC,sBAAsB,EAAE,KADhB;QAERC,YAAY,EAAE,KAFN;QAGRC,aAAa,EAAE,EAHP;QAIRJ;MAJQ,CAAZ;;MAMA,IAAID,MAAM,CAACM,QAAP,KAAoBlC,6BAAxB,EAAuD;QACnD4B,MAAM,CAACO,KAAP,CAAalC,SAAS,CAACmC,wBAAvB,EAAiD,4BAAjD;QACA,OAAO,OAAOC,IAAP,EAAaC,MAAb,KAAwB;UAC3B;UACA,OAAOrB,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACa,GAAD,EAAMO,IAAN,EAAYC,MAAZ,CAAhE;QACH,CAHD;MAIH,CAbiB,CAclB;MACA;;;MACA,MAAMC,kBAAkB,GAAGzB,yBAAyB,GAAG,CAA5B,IAAiC0B,QAAQ,CAAC1B,yBAAD,CAAzC,GACrB2B,UAAU,CAAC,MAAM;QACf,IAAI,CAACX,GAAG,CAACC,sBAAT,EACIH,MAAM,CAACO,KAAP,CAAalC,SAAS,CAACyC,+BAAvB,EAAwD,mCAAxD;MACP,CAHW,EAGT5B,yBAHS,CADW,GAKrB,IALN;MAMAc,MAAM,CAACe,SAAP,CAAiB,eAAeA,SAAf,CAAyBC,IAAzB,EAA+B;QAC5C,IAAIC,GAAJ,EAASC,EAAT;;QACA,IAAIC,EAAJ;;QACA,IAAIC,OAAJ;;QACA,IAAI;UACAA,OAAO,GAAG5C,YAAY,CAACwC,IAAD,EAAOpB,OAAP,CAAtB;QACH,CAFD,CAGA,OAAOyB,GAAP,EAAY;UACR,OAAOrB,MAAM,CAACO,KAAP,CAAalC,SAAS,CAACiD,UAAvB,EAAmC,0BAAnC,CAAP;QACH;;QACD,QAAQF,OAAO,CAACG,IAAhB;UACI,KAAKjD,WAAW,CAACkD,cAAjB;YAAiC;cAC7B,IAAItB,GAAG,CAACC,sBAAR,EACI,OAAOH,MAAM,CAACO,KAAP,CAAalC,SAAS,CAACoD,6BAAvB,EAAsD,kCAAtD,CAAP,CAFyB,CAG7B;;cACAvB,GAAG,CAACC,sBAAJ,GAA6B,IAA7B;cACA,IAAI1B,QAAQ,CAAC2C,OAAO,CAACM,OAAT,CAAZ,EACI;gBACAxB,GAAG,CAACyB,gBAAJ,GAAuBP,OAAO,CAACM,OAA/B;cACJ,MAAME,kBAAkB,GAAG,OAAOzC,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACe,GAAD,CAAtE,CAA3B;cACA,IAAI0B,kBAAkB,KAAK,KAA3B,EACI,OAAO5B,MAAM,CAACO,KAAP,CAAalC,SAAS,CAACwD,SAAvB,EAAkC,WAAlC,CAAP;cACJ,MAAM7B,MAAM,CAAC8B,IAAP,CAAYvD,gBAAgB,CAACE,QAAQ,CAACmD,kBAAD,CAAR,GAC7B;gBACEL,IAAI,EAAEjD,WAAW,CAACyD,aADpB;gBAEEL,OAAO,EAAEE;cAFX,CAD6B,GAK7B;gBACEL,IAAI,EAAEjD,WAAW,CAACyD,aADpB,CAEE;;cAFF,CAL4B,EAQ3BjC,QAR2B,CAA5B,CAAN,CAX6B,CAoB7B;;cACAI,GAAG,CAACE,YAAJ,GAAmB,IAAnB;cACA;YACH;;UACD,KAAK9B,WAAW,CAAC0D,IAAjB;YAAuB;cACnB,IAAIhC,MAAM,CAACiC,MAAX,EACI;gBACA,OAAO,MAAMjC,MAAM,CAACiC,MAAP,CAAcb,OAAO,CAACM,OAAtB,CAAb;cACJ,MAAM1B,MAAM,CAAC8B,IAAP,CAAYvD,gBAAgB,CAAC6C,OAAO,CAACM,OAAR,GAC7B;gBAAEH,IAAI,EAAEjD,WAAW,CAAC4D,IAApB;gBAA0BR,OAAO,EAAEN,OAAO,CAACM;cAA3C,CAD6B,GAE7B;gBACEH,IAAI,EAAEjD,WAAW,CAAC4D,IADpB,CAEE;;cAFF,CAF4B,CAA5B,CAAN;cAMA;YACH;;UACD,KAAK5D,WAAW,CAAC4D,IAAjB;YACI,OAAO,OAAO,CAACf,EAAE,GAAGnB,MAAM,CAACmC,MAAb,MAAyB,IAAzB,IAAiChB,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAACtE,IAAH,CAAQmD,MAAR,EAAgBoB,OAAO,CAACM,OAAxB,CAAjE,CAAP;;UACJ,KAAKpD,WAAW,CAAC8D,SAAjB;YAA4B;cACxB,IAAI,CAAClC,GAAG,CAACE,YAAT,EACI,OAAOJ,MAAM,CAACO,KAAP,CAAalC,SAAS,CAACgE,YAAvB,EAAqC,cAArC,CAAP;cACJ,MAAM;gBAAEC,EAAF;gBAAMZ;cAAN,IAAkBN,OAAxB;cACA,IAAIkB,EAAE,IAAIpC,GAAG,CAACG,aAAd,EACI,OAAOL,MAAM,CAACO,KAAP,CAAalC,SAAS,CAACkE,uBAAvB,EAAiD,kBAAiBD,EAAG,iBAArE,CAAP,CALoB,CAMxB;cACA;;cACApC,GAAG,CAACG,aAAJ,CAAkBiC,EAAlB,IAAwB,IAAxB;cACA,MAAME,IAAI,GAAG;gBACTC,IAAI,EAAE,OAAOC,MAAP,EAAeC,IAAf,KAAwB;kBAC1B,IAAIC,WAAW,GAAG;oBACdN,EADc;oBAEdf,IAAI,EAAEjD,WAAW,CAACuE,IAFJ;oBAGdnB,OAAO,EAAEgB;kBAHK,CAAlB;kBAKA,MAAMI,WAAW,GAAG,OAAOtD,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACU,GAAD,EAAM0C,WAAN,EAAmBD,IAAnB,EAAyBD,MAAzB,CAA7D,CAApB;kBACA,IAAII,WAAJ,EACIF,WAAW,GAAGG,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,WAAlB,CAAd,EAA8C;oBAAElB,OAAO,EAAEoB;kBAAX,CAA9C,CAAd;kBACJ,MAAM9C,MAAM,CAAC8B,IAAP,CAAYvD,gBAAgB,CAACqE,WAAD,EAAc9C,QAAd,CAA5B,CAAN;gBACH,CAXQ;gBAYTmD,KAAK,EAAE,MAAOC,MAAP,IAAkB;kBACrB,IAAIC,YAAY,GAAG;oBACfb,EADe;oBAEff,IAAI,EAAEjD,WAAW,CAAC8E,KAFH;oBAGf1B,OAAO,EAAEwB;kBAHM,CAAnB;kBAKA,MAAMG,WAAW,GAAG,OAAO5D,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACS,GAAD,EAAMiD,YAAN,EAAoBD,MAApB,CAAhE,CAApB;kBACA,IAAIG,WAAJ,EACIF,YAAY,GAAGJ,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBG,YAAlB,CAAd,EAA+C;oBAAEzB,OAAO,EAAE2B;kBAAX,CAA/C,CAAf;kBACJ,MAAMrD,MAAM,CAAC8B,IAAP,CAAYvD,gBAAgB,CAAC4E,YAAD,EAAerD,QAAf,CAA5B,CAAN;gBACH,CAtBQ;gBAuBTwD,QAAQ,EAAE,MAAOC,YAAP,IAAwB;kBAC9B,MAAMC,eAAe,GAAG;oBACpBlB,EADoB;oBAEpBf,IAAI,EAAEjD,WAAW,CAACmF;kBAFE,CAAxB;kBAIA,OAAO/D,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACQ,GAAD,EAAMsD,eAAN,CAAzE;kBACA,IAAID,YAAJ,EACI,MAAMvD,MAAM,CAAC8B,IAAP,CAAYvD,gBAAgB,CAACiF,eAAD,EAAkB1D,QAAlB,CAA5B,CAAN;gBACP;cA/BQ,CAAb;;cAiCA,IAAI;gBACA,IAAI4D,QAAJ;gBACA,MAAMC,qBAAqB,GAAG,OAAOrE,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,WAAW,CAACY,GAAD,EAAMkB,OAAN,CAA5E,CAA9B;;gBACA,IAAIuC,qBAAJ,EAA2B;kBACvB,IAAI/E,gBAAgB,CAAC+E,qBAAD,CAApB,EACI,OAAO,MAAMnB,IAAI,CAACS,KAAL,CAAWU,qBAAX,CAAb,CADJ,KAEK,IAAIC,KAAK,CAACC,OAAN,CAAcF,qBAAd,CAAJ,EACD,MAAM,IAAIP,KAAJ,CAAU,uFAAV,CAAN,CAJmB,CAKvB;;kBACAM,QAAQ,GAAGC,qBAAX;gBACH,CAPD,MAQK;kBACD;kBACA;kBACA,IAAI,CAAC5E,MAAL,EACI,MAAM,IAAIqE,KAAJ,CAAU,oCAAV,CAAN;kBACJ,MAAMT,IAAI,GAAG;oBACTmB,aAAa,EAAEpC,OAAO,CAACoC,aADd;oBAETC,QAAQ,EAAEpG,KAAK,CAAC+D,OAAO,CAACsC,KAAT,CAFN;oBAGTC,cAAc,EAAEvC,OAAO,CAACwC;kBAHf,CAAb;kBAKAR,QAAQ,GAAGX,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,IAAlB,CAAd,EAAuC;oBAAE5D,MAAM,EAAE,OAAOA,MAAP,KAAkB,UAAlB,GAClD,MAAMA,MAAM,CAACmB,GAAD,EAAMkB,OAAN,EAAeuB,IAAf,CADsC,GAElD5D;kBAFwC,CAAvC,CAAX;kBAGA,MAAMoF,gBAAgB,GAAG,CAACvG,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2CA,QAA3C,GAAsDC,eAAvD,EAAwE6F,QAAQ,CAAC3E,MAAjF,EAAyF2E,QAAQ,CAACK,QAAlG,CAAzB;kBACA,IAAII,gBAAgB,CAACC,MAAjB,GAA0B,CAA9B,EACI,OAAO,MAAM5B,IAAI,CAACS,KAAL,CAAWkB,gBAAX,CAAb;gBACP;;gBACD,MAAME,YAAY,GAAGnG,eAAe,CAACwF,QAAQ,CAACK,QAAV,EAAoBL,QAAQ,CAACI,aAA7B,CAApC;gBACA,IAAI,CAACO,YAAL,EACI,OAAO,MAAM7B,IAAI,CAACS,KAAL,CAAW,CACpB,IAAI9E,YAAJ,CAAiB,8BAAjB,CADoB,CAAX,CAAb,CA9BJ,CAiCA;;gBACA,IAAI,EAAE,eAAeuF,QAAjB,CAAJ,EACIA,QAAQ,CAACY,SAAT,GAAqBrF,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACoF,YAAY,CAACE,SAAd,CAAxE,CAnCJ,CAoCA;;gBACA,IAAI,EAAE,kBAAkBb,QAApB,CAAJ,EACIA,QAAQ,CAACc,YAAT,GACI,OAAOxF,OAAP,KAAmB,UAAnB,GACM,MAAMA,OAAO,CAACkB,GAAD,EAAMkB,OAAN,EAAesC,QAAf,CADnB,GAEM1E,OAHV,CAtCJ,CA0CA;gBACA;;gBACA,IAAIyF,eAAJ;gBACA,IAAIJ,YAAY,CAACE,SAAb,KAA2B,cAA/B,EACIE,eAAe,GAAG,MAAM,CAACzG,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6CA,SAA7C,GAAyDC,gBAA1D,EAA4EyF,QAA5E,CAAxB,CADJ,CAEA;gBAFA,KAIIe,eAAe,GAAG,MAAM,CAAC3G,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyCA,OAAzC,GAAmDC,cAApD,EAAoE2F,QAApE,CAAxB;gBACJ,MAAMZ,WAAW,GAAG,OAAOvD,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,WAAW,CAACW,GAAD,EAAMkB,OAAN,EAAesC,QAAf,EAAyBe,eAAzB,CAA5E,CAApB;gBACA,IAAI3B,WAAJ,EACI2B,eAAe,GAAG3B,WAAlB;;gBACJ,IAAInE,eAAe,CAAC8F,eAAD,CAAnB,EAAsC;kBAClC;kBACA,IAAI,EAAEnC,EAAE,IAAIpC,GAAG,CAACG,aAAZ,CAAJ,EAAgC;oBAC5B;oBACA,IAAI3B,gBAAgB,CAAC+F,eAAD,CAApB,EACIA,eAAe,CAACC,MAAhB,CAAuBC,SAAvB;kBACP,CAJD,MAKK;oBACDzE,GAAG,CAACG,aAAJ,CAAkBiC,EAAlB,IAAwBmC,eAAxB;;oBACA,IAAI;sBACA,KAAK,IAAIG,iBAAiB,GAAGtI,aAAa,CAACmI,eAAD,CAArC,EAAwDI,mBAA7D,EAAkFA,mBAAmB,GAAG,MAAMD,iBAAiB,CAACnC,IAAlB,EAA5B,EAAsD,CAACoC,mBAAmB,CAACtH,IAA7J,GAAoK;wBAChK,MAAMmF,MAAM,GAAGmC,mBAAmB,CAACrH,KAAnC;wBACA,MAAMgF,IAAI,CAACC,IAAL,CAAUC,MAAV,EAAkBgB,QAAlB,CAAN;sBACH;oBACJ,CALD,CAMA,OAAOoB,KAAP,EAAc;sBAAE7D,GAAG,GAAG;wBAAEgC,KAAK,EAAE6B;sBAAT,CAAN;oBAAyB,CANzC,SAOQ;sBACJ,IAAI;wBACA,IAAID,mBAAmB,IAAI,CAACA,mBAAmB,CAACtH,IAA5C,KAAqD2D,EAAE,GAAG0D,iBAAiB,CAACF,MAA5E,CAAJ,EAAyF,MAAMxD,EAAE,CAACrE,IAAH,CAAQ+H,iBAAR,CAAN;sBAC5F,CAFD,SAGQ;wBAAE,IAAI3D,GAAJ,EAAS,MAAMA,GAAG,CAACgC,KAAV;sBAAkB;oBACxC;kBACJ;gBACJ,CAvBD,MAwBK;kBACD;kBACA;kBACA;kBACA,IAAIX,EAAE,IAAIpC,GAAG,CAACG,aAAd,EACI,MAAMmC,IAAI,CAACC,IAAL,CAAUgC,eAAV,EAA2Bf,QAA3B,CAAN;gBACP,CAnFD,CAoFA;gBACA;;;gBACA,MAAMlB,IAAI,CAACc,QAAL,CAAchB,EAAE,IAAIpC,GAAG,CAACG,aAAxB,CAAN;cACH,CAvFD,SAwFQ;gBACJ;gBACA,OAAOH,GAAG,CAACG,aAAJ,CAAkBiC,EAAlB,CAAP;cACH;;cACD;YACH;;UACD,KAAKhE,WAAW,CAACmF,QAAjB;YAA2B;cACvB,MAAMsB,YAAY,GAAG7E,GAAG,CAACG,aAAJ,CAAkBe,OAAO,CAACkB,EAA1B,CAArB;cACA,OAAOpC,GAAG,CAACG,aAAJ,CAAkBe,OAAO,CAACkB,EAA1B,CAAP,CAFuB,CAEe;;cACtC,IAAI5D,gBAAgB,CAACqG,YAAD,CAApB,EACI,MAAMA,YAAY,CAACL,MAAb,CAAoBC,SAApB,CAAN;cACJ;YACH;;UACD;YACI,MAAM,IAAIvB,KAAJ,CAAW,8BAA6BhC,OAAO,CAACG,IAAK,WAArD,CAAN;QAvLR;MAyLH,CAnMD,EAtBkB,CA0NlB;;MACA,OAAO,OAAOd,IAAP,EAAaC,MAAb,KAAwB;QAC3B,IAAIC,kBAAJ,EACIqE,YAAY,CAACrE,kBAAD,CAAZ;;QACJ,KAAK,MAAMsE,GAAX,IAAkBlC,MAAM,CAACmC,MAAP,CAAchF,GAAG,CAACG,aAAlB,CAAlB,EAAoD;UAChD,IAAI3B,gBAAgB,CAACuG,GAAD,CAApB,EACI,MAAMA,GAAG,CAACP,MAAJ,CAAWC,SAAX,CAAN;QACP;;QACD,IAAIzE,GAAG,CAACE,YAAR,EACI,OAAOhB,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAACc,GAAD,EAAMO,IAAN,EAAYC,MAAZ,CAA/E;QACJ,OAAOrB,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACa,GAAD,EAAMO,IAAN,EAAYC,MAAZ,CAAhE;MACH,CAVD;IAWH;;EAvOE,CAAP;AAyOH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASyE,eAAT,CAAyBC,SAAzB,EAAoC;EACvC,QAAQ,IAAR;IACI,KAAKA,SAAS,YAAYC,GAArB,IACDD,SAAS,CAACE,GAAV,CAAclH,6BAAd,CADJ;IAEA,KAAKwF,KAAK,CAACC,OAAN,CAAcuB,SAAd,KACDA,SAAS,CAACG,QAAV,CAAmBnH,6BAAnB,CADJ;IAEA,KAAK,OAAOgH,SAAP,KAAqB,QAArB,IACDA,SAAS,CACJI,KADL,CACW,GADX,EAEKC,GAFL,CAEUC,CAAD,IAAOA,CAAC,CAACC,IAAF,EAFhB,EAGKJ,QAHL,CAGcnH,6BAHd,CADJ;MAKI,OAAOA,6BAAP;;IACJ;MACI,OAAO,KAAP;EAZR;AAcH"},"metadata":{},"sourceType":"module"}